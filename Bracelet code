def FibbonacciN(x,y,n=10):#implements fibbonacci mod n
    sequence = [x,y]
    pairs = []
    while sequence[-2:] not in pairs:
        pairs.append(sequence[-2:])
        z = (x+y) % n #finds the next term of the sequence
        sequence.append(z)
        x,y = y,z
    return sequence[:-2], len(sequence[:-2]) #output our sequence, and the length of the sequence if it ends
   
def AllBracelets(n=10):#calculate the number of possible bracelets in Mod n
    bracelets=set() #creates a set of all bracelets
    for i in range(n):
        for j in range(n):
            bracelets.add(tuple(normalised(FibbonacciN(i,j,n)[0],n)))
    return len(bracelets), bracelets

def normalised(bracelet,n=10):#normalise our bracelets to start from the same numbers
    BestPair = n**2-1
    for i in range(len(bracelet)):    
        NumberPair = n*bracelet[i]+ (bracelet[(i+1)%len(bracelet)]) #taking a pair in our bracelet and assigning it a value for comparison
        if NumberPair < BestPair:
            BestPair = NumberPair
    return FibbonacciN(BestPair//n,BestPair % n,n)[0]
